{% assign variant_metafields_string = '' %}
{% for product in collections['uncategorized'].products %}
  {% for variant in product.variants %}
    {% if variant.metafields.global.description != blank %}
      {% assign variant_metafields_string = variant_metafields_string | append: variant.id | append: '<delimiter_first>' | append: variant.metafields.global.description | append: '<delimiter_second>' %}
    {% endif %}
  {% endfor %}
{% endfor %}
{% liquid
  assign last_character = variant_metafields_string | slice: -1
  assign vms_length_min_one = variant_metafields_string.size | minus: 1
%}
{% if last_character == '<delimiter_second>' %}
  {% assign variant_metafields_string = variant_metafields_string | slice: 0, vms_length_min_one %}
{% endif %}

{% assign variant_real_price_string = '' %}
{% for product in collections['uncategorized'].products %}
  {% for variant in product.variants %}
    {% if variant.metafields.custom.real_price != blank %}
      {% assign variant_real_price_string = variant_real_price_string | append: variant.id | append: '<delimiter_first>' | append: variant.metafields.custom.real_price | append: '<delimiter_second>' %}
    {% endif %}
  {% endfor %}
{% endfor %}
{% liquid
  assign last_character_vrp = variant_real_price_string | slice: -1
  assign vrp_length_min_one = variant_real_price_string.size | minus: 1
%}
{% if last_character_vrp == '<delimiter_second>' %}
  {% assign variant_real_price_string = variant_real_price_string | slice: 0, vrp_length_min_one %}
{% endif %}

{%  style  %}
  .gpo-tooltip.zoom-image {
    display: none !important;
  }

  .gpo-swatch__image {
    display: none !important;
  }

  .gpo-ov-item.gpo-hidden-original {
    display: none !important;
  }

  .custom-variant-card {
    border: 1px solid #d1d5db;
    border-radius: 6px;
    padding: 16px;
    margin-bottom: 12px;
    background: white;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 16px;
    position: relative;
  }

  .custom-variant-card:hover {
    border-color: #9ca3af;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }

  .custom-variant-card.selected {
    border-color: #16a085;
    border-width: 2px;
    padding: 15px;
    background-color: #f0fdf9;
  }

  .card-image-container {
    flex-shrink: 0;
    width: 64px;
    height: 64px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #f9fafb;
    border-radius: 4px;
    overflow: hidden;
  }

  .card-image {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
  }

  .card-content {
    flex: 1;
    min-width: 0;
  }

  .card-title {
    font-size: 15px;
    font-weight: 600;
    margin: 0 0 4px 0;
    color: #111827;
    line-height: 1.4;
  }

  .card-price-section {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 6px;
  }

  .card-price-current {
    font-size: 16px;
    font-weight: 700;
    color: #111827;
  }

  .card-save-badge {
    background: #16a085;
    color: white;
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
  }

  .card-price-was {
    font-size: 13px;
    color: #9ca3af;
    text-decoration: line-through;
  }

  .card-free-badge {
    color: #16a085;
    font-size: 13px;
    font-weight: 600;
  }

  input[gpo-data-variant-id] {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }

  @media (max-width: 768px) {
    .custom-variant-card {
      flex-direction: row;
      text-align: left;
    }

    .card-image-container {
      width: 56px;
      height: 56px;
    }

    .card-title {
      font-size: 14px;
    }

    .card-price-current {
      font-size: 15px;
    }
  }

  .freebies .custom-variant-card {
    background: #f5f5f5;
    border-color: #000;
    opacity: 0.7;
    cursor: not-allowed;
  }

  .freebies .custom-variant-card.selected {
    opacity: 1;
  }
{% endstyle %}

<script>
  const vmsString = {{variant_metafields_string | json}};
  const vrpString = {{variant_real_price_string | json}};
  const vmMap = new Map();
  const vrpMap = new Map();
  const priceCache = new Map();
  const processedVariants = new Set();
  let isInitialLoad = true;

  vrpString
    .split("<delimiter_second>")
    .map((val) => val.split("<delimiter_first>"))
    .forEach(([id, price]) => {
      if (id && price) vrpMap.set(id, price);
    });

  vmsString
    .split("<delimiter_second>")
    .map((val) => val.split("<delimiter_first>"))
    .forEach(([id, description]) => {
      if (id && description) vmMap.set(id, description);
    });

  function isFreebieInput(input) {
    const inFreebiesContainer = input.closest('.freebies') !== null;
    const parentHasFreebieClass = input.parentElement?.classList.contains('freebies') || 
                                   input.parentElement?.parentElement?.classList.contains('freebies');
    
    const fieldName = input.getAttribute('data-field-name')?.toLowerCase() || '';
    const dataName = input.getAttribute('data-name')?.toLowerCase() || '';
    
    return inFreebiesContainer || 
           parentHasFreebieClass || 
           fieldName.includes('freebie') || 
           dataName.includes('freebie');
  }

  function isSingleOptionRadio(input) {
    if (input.type !== 'radio') return false;
    
    const name = input.name;
    const siblings = document.querySelectorAll(`input[type="radio"][name="${name}"][gpo-data-variant-id]`);
    const count = siblings.length;
    
    console.log(`Radio ${name} has ${count} options`);
    return count === 1;
  }

  function hasAllPrices() {
    const inputs = document.querySelectorAll('input[gpo-data-variant-id]');
    let nonFreebieCount = 0;
    let addOnCount = 0;
    
    inputs.forEach(input => {
      if (!isFreebieInput(input)) {
        nonFreebieCount++;
        const addOn = input.nextElementSibling?.querySelector('.addOn');
        if (addOn) {
          addOnCount++;
        }
      }
    });
    
    console.log(`Price check: ${addOnCount}/${nonFreebieCount} non-freebie items have prices`);
    
    // Need at least 80% of prices loaded
    return addOnCount > 0 && (addOnCount / nonFreebieCount) > 0.8;
  }

  function extractAndCachePrices() {
    const inputs = document.querySelectorAll('input[gpo-data-variant-id]');
    let extracted = 0;
    
    inputs.forEach(input => {
      const variantId = input.getAttribute('gpo-data-variant-id');
      
      if (isFreebieInput(input)) {
        if (!priceCache.has(variantId)) {
          priceCache.set(variantId, '0');
          extracted++;
        }
        return;
      }
      
      const addOn = input.nextElementSibling?.querySelector('.addOn');
      
      if (addOn) {
        const text = addOn.textContent.trim();
        
        if (text.toLowerCase().includes('free')) {
          priceCache.set(variantId, '0');
          extracted++;
        } else {
          const match = text.match(/[\d,]+/);
          if (match) {
            const price = match[0].replace(/,/g, '');
            priceCache.set(variantId, price);
            extracted++;
          }
        }
      }
    });
    
    return extracted > 0;
  }

  function getImageUrl(input) {
    const swatchImage = input.nextElementSibling?.querySelector('.gpo-swatch__image');
    if (swatchImage) {
      return swatchImage.src || swatchImage.getAttribute('data-src');
    }

    const tooltipImage = input.nextElementSibling?.querySelector('.gpo-tooltip__image img');
    if (tooltipImage) {
      return tooltipImage.src || tooltipImage.getAttribute('data-src');
    }

    return '';
  }

  function getProductName(input) {
    const tooltipTitle = input.nextElementSibling?.querySelector('.gpo-tooltip__title');
    if (tooltipTitle) {
      const clone = tooltipTitle.cloneNode(true);
      const addon = clone.querySelector('.addOn');
      if (addon) addon.remove();
      return clone.textContent.trim();
    }
    return 'Product Option';
  }

  function createVariantCard(input, variantId) {
    const imageUrl = getImageUrl(input);
    const productName = getProductName(input);
    const currentPriceRaw = priceCache.get(variantId);
    const realPrice = vrpMap.get(variantId);
    const isFreebie = isFreebieInput(input);
    const isSingleRadio = isSingleOptionRadio(input);

    const card = document.createElement('div');
    card.className = 'custom-variant-card';
    card.setAttribute('data-variant-id', variantId);

    let priceHTML = '';
    
    if (!currentPriceRaw || currentPriceRaw === '0' || currentPriceRaw === '' || isFreebie) {
      priceHTML = '<div class="card-free-badge">FREE - Included with your order</div>';
    } else {
      const currentPrice = parseInt(currentPriceRaw);
      const currentPriceFormatted = `$${currentPrice.toLocaleString("en-US")}`;
      
      if (realPrice) {
        const realPriceNum = parseInt(realPrice);
        const savings = realPriceNum - currentPrice;
        priceHTML = `
          <div class="card-price-section">
            <span class="card-price-current">${currentPriceFormatted}</span>
            <span class="card-save-badge">Save $${savings.toLocaleString("en-US")}</span>
            <span class="card-price-was">$${realPriceNum.toLocaleString("en-US")} USD</span>
          </div>
        `;
      } else {
        priceHTML = `
          <div class="card-price-section">
            <span class="card-price-current">${currentPriceFormatted}</span>
          </div>
        `;
      }
    }

    card.innerHTML = `
      ${imageUrl ? `
        <div class="card-image-container">
          <img src="${imageUrl}" alt="${productName}" class="card-image">
        </div>
      ` : ''}
      <div class="card-content">
        <h3 class="card-title">${productName}</h3>
        ${priceHTML}
      </div>
    `;

    card.addEventListener('click', (e) => {
      e.preventDefault();
      
      if (isFreebie) {
        console.log('Freebies cannot be toggled');
        return;
      }
      
      if (input.type === 'checkbox') {
        input.checked = !input.checked;
        console.log(`Checkbox toggled: ${input.checked}`);
      } else if (input.type === 'radio') {
        if (isSingleRadio) {
          // For single-option radios, allow unchecking
          input.checked = !input.checked;
          console.log(`Single-option radio toggled: ${input.checked}`);
        } else {
          input.checked = true;
          console.log(`Multi-option radio checked`);
        }
      }
      
      const event = new Event('change', { bubbles: true });
      input.dispatchEvent(event);
      updateSelectedStates(input);
    });

    return card;
  }

  function updateSelectedStates(selectedInput) {
    const inputName = selectedInput.name;
    const groupInputs = document.querySelectorAll(`input[name="${inputName}"]`);
    
    groupInputs.forEach(input => {
      const variantId = input.getAttribute('gpo-data-variant-id');
      const card = document.querySelector(`.custom-variant-card[data-variant-id="${variantId}"]`);
      
      if (card) {
        if (input.checked) {
          card.classList.add('selected');
        } else {
          card.classList.remove('selected');
        }
      }
    });
  }

  function removeCardsForMissingInputs() {
    const existingCards = document.querySelectorAll('.custom-variant-card');
    
    existingCards.forEach(card => {
      const variantId = card.getAttribute('data-variant-id');
      const input = document.querySelector(`input[gpo-data-variant-id="${variantId}"]`);
      
      if (!input) {
        console.log(`Removing card for missing input: ${variantId}`);
        card.remove();
        processedVariants.delete(variantId);
      }
    });
  }

  function processVariantInputs() {
    const inputs = document.querySelectorAll('input[gpo-data-variant-id]');
    
    let newCardsCreated = 0;
    
    inputs.forEach(input => {
      const variantId = input.getAttribute('gpo-data-variant-id');
      
      if (processedVariants.has(variantId)) {
        return;
      }

      const card = createVariantCard(input, variantId);
      
      const ovItem = input.closest('.gpo-ov-item');
      if (ovItem && ovItem.parentElement) {
        ovItem.parentElement.insertBefore(card, ovItem);
        ovItem.classList.add('gpo-hidden-original');
        processedVariants.add(variantId);
        newCardsCreated++;
      }

      if (input.checked) {
        card.classList.add('selected');
      }

      input.addEventListener('change', () => {
        updateSelectedStates(input);
      });
    });
    
    if (newCardsCreated > 0) {
      console.log(`Created ${newCardsCreated} new cards`);
    }
  }

  function waitForElement(selector, callback, timeout = 10000) {
    const startTime = Date.now();
    
    const observer = new MutationObserver(() => {
      const el = document.querySelector(selector);
      if (el) {
        observer.disconnect();
        callback(el);
      } else if (Date.now() - startTime > timeout) {
        observer.disconnect();
        console.warn(`Timeout waiting for ${selector}`);
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });

    const el = document.querySelector(selector);
    if (el) {
      observer.disconnect();
      callback(el);
    }
  }

  function waitForPrices(callback, maxRetries = 20, delay = 300) {
    let retries = 0;
    
    const checkPrices = () => {
      const extracted = extractAndCachePrices();
      const hasPrices = hasAllPrices();
      
      if ((extracted && hasPrices) || retries >= maxRetries) {
        console.log(`Prices ready: extracted=${extracted}, hasPrices=${hasPrices}, retries=${retries}`);
        callback();
      } else {
        retries++;
        console.log(`Waiting for prices... retry ${retries}/${maxRetries}`);
        setTimeout(checkPrices, delay);
      }
    };
    
    checkPrices();
  }

  // Main initialization
  document.addEventListener("DOMContentLoaded", function () {
    console.log('DOM Content Loaded');
      
    // Wait for inputs, then do a QUICK initial render
    waitForElement('input[gpo-data-variant-id]', () => {
      console.log('Found Globo inputs, doing quick initial render...');
      
      // 1) Grab whatever prices we can right now
      extractAndCachePrices();
      // 2) Build cards immediately so UI appears fast
      processVariantInputs();
      // 3) Allow mutation observer to start reacting
      isInitialLoad = false;

      // Optional refinement: run waitForPrices in the background
      // to update any late-loading prices (doesn't block the first render)
      waitForPrices(() => {
        console.log('Refining prices after async load');
        extractAndCachePrices();
        processVariantInputs();
      });
    });

    // Watch for dynamic additions
    let processingTimeout = null;
    
    const observer = new MutationObserver((mutations) => {
      // Skip during initial load
      if (isInitialLoad) return;
      
      let hasNewElements = false;
      let hasFreebieChanges = false;
      let hasRemovals = false;
      
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === 1) {
            if (node.classList?.contains('addOn') || node.querySelector?.('.addOn')) {
              hasNewElements = true;
            }
            
            if (node.classList?.contains('freebies') || node.querySelector?.('.freebies')) {
              hasFreebieChanges = true;
              console.log('ðŸŽ Freebies container added');
            }
            
            if (node.classList?.contains('gpo-swatches') || 
                node.querySelector?.('.gpo-swatches') ||
                node.getAttribute?.('gpo-data-variant-id')) {
              hasNewElements = true;
            }
          }
        });
        
        mutation.removedNodes.forEach((node) => {
          if (node.nodeType === 1) {
            if (node.classList?.contains('gpo-ov-item') || node.querySelector?.('.gpo-ov-item')) {
              hasRemovals = true;
            }
          }
        });
      });

      if (hasNewElements || hasFreebieChanges || hasRemovals) {
        if (processingTimeout) {
          clearTimeout(processingTimeout);
        }
        
        const delay = hasFreebieChanges ? 1000 : 300;
        
        processingTimeout = setTimeout(() => {
          console.log('Processing changes...');
          
          if (hasRemovals) {
            removeCardsForMissingInputs();
          }
          
          extractAndCachePrices();
          processVariantInputs();
        }, delay);
      }
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  });
</script>
